STARTER PROJECT
=================
Lab7_HeartBlock

Learning Objectives
=================
In this chapter, we will begin by presenting a general approach to modular design. In specific, we will discuss how to organize software blocks in an effective manner. The ultimate success of an embedded system project depends both on its software and hardware. Computer scientists pride themselves in their ability to develop quality software. Similarly electrical engineers are well-trained in the processes to design both digital and analog electronics. Manufacturers, in an attempt to get designers to use their products, provide application notes for their hardware devices. The main objective of this class is to combine effective design processes together with practical software techniques in order to develop quality embedded systems. As the size and especially the complexity of the software increase, the software development changes from simple "coding" to "software engineering", and the required skills also vary along this spectrum. These software skills include modular design, layered architecture, abstraction, and verification. Real-time embedded systems are usually on the small end of the size scale, but never the less these systems can be quite complex. Therefore, both hardware and software skills are essential for developing embedded systems. Writing good software is an art that must be developed, and cannot be added on at the end of a project. Just like any other discipline (e.g., music, art, science, religion), expertise comes from a combination of study and practice. The watchful eye of a good mentor can be invaluable, so take the risk and show your software to others inviting praise and criticism. Good software combined with average hardware will always outperform average software on good hardware. In this chapter we will introduce some techniques for developing quality software.

Learning Objectives
=================

* Understand system development process as a life cycle
* Take requirements and formulate a problem statement.
* Learn that an algorithm is a formal way to describe a solution
* Define an algorithm with pseudo code or visually as a flowchart
* Translate flowchart to code
* Test in simulator (Test ? Write code ? Test ? Write code … cycle)
* Run on real board

[![IMAGE ALT TEXT](http://img.youtube.com/vi/7O-2bjXOjQQ/0.jpg)](http://www.youtube.com/watch?v=7O-2bjXOjQQ "Video Title")